/* ******************************
  Copyright 2025 - Ilyes Chaabeni
 ****************************** */

#ifndef GLWOA_RRTSTAR_PLANNER_WOA_AGENT_HPP_  // NOLINT
#define GLWOA_RRTSTAR_PLANNER_WOA_AGENT_HPP_

#include <ros/ros.h>
#include <costmap_2d/costmap_2d.h>
#include "glwoa_rrtstar_planner/random_double_generator.hpp"
#include "glwoa_rrtstar_planner/random_int_generator.hpp"
#include "glwoa_rrtstar_planner/collision_detector.hpp"
#include "glwoa_rrtstar_planner/node.hpp"

#include <cmath>
#include <list>
#include <utility>
#include <cstdint>
#include <armadillo>

namespace glwoa_rrtstar_planner {

// TODO: Use a more efficient approach to handle the path when it is out of bounds
//       or when it collides with an obstacle.

/**
 * @brief Class that allows to handle a single WOA agent as a path in the search space. It can be modified and used in any variant of WOA.
 */
class PathAgent {
 public:
 /**
   * @brief Constructor for PathAgent
   * @param path The initial path generated by RRT*
   * @param sampling_radius The radius within which to sample points during agents initialization
   * @param id The unique identifier for the agent
   * @param costmap Pointer to the costmap used for collision detection
   * @param spiral_shape The shape parameter "b" for the spiral search
   */
  PathAgent(std::list<std::pair<float, float>> &path,
            const float sampling_radius,
            uint16_t id,
            costmap_2d::Costmap2D* costmap,
            float spiral_shape);

  //  // Move constructor (if needed)
  // PathAgent(PathAgent&& other) noexcept;
  // // Move assignment operator
  // PathAgent& operator=(PathAgent&& other) noexcept;
 
  // public data variables
  float sampling_radius_{0.1};
  costmap_2d::Costmap2D* costmap_{nullptr};

  float time_spiral_update_{0.0};
  float time_circular_update_{0.0};

  // the agent's vector representing the path
  arma::vec X;
  // arma::vec Xnew;
  // updated in each iteration
  double A{0.0};
  // updated in each iteration
  double C{0.0};
  // updated in each iteration
  double l{0.0};
  uint16_t vec_size;
  double b; // spiral shape parameter
  std::pair<float, float> start_point_;
  std::pair<float, float> goal_point_;
  std::list<std::pair<float, float>> initial_path_; // for display

  /**
   * @brief uses circular search to update the agent Xi 
   * @param search_agent The search agent, either Xbest or Xrand
   */
  void circularUpdate(const arma::vec &search_agent);

  /**
   * @brief uses spiral search to update the agent Xi 
   * @param search_agent The search agent, which is Xbest
   */
  void spiralUpdate(const arma::vec &search_agent);

  /**
   * @brief Computes the cost of the agent 
   * @return float representing the length of the path
   */
  double fitness() ;

  /**
   * @brief gets the index / id of the PahtAgent object
   * @return the id (index) of the agent
   */
  uint16_t getID();

  /**
   * @brief Generates random initial paths for WOA initialization based on the RRT* initial path
   * @return a path close to initial path
   * @param path: the initial path generated by RRT*
   */
  std::list<std::pair<float, float>> randomInitialPath(const std::list<std::pair<float, float>> &path);

  /**
   * @brief checks if the agent's path collides
   * @return true if the path collides
   */
  bool doesPathCollide();

  /**
   * @brief clamps the agent's path to the map bounds (point by point). The return is for debugging purposes.
   * @return Return whether the path was initially out of bounds (i.e., at least one point was outside the map bounds).
   */
  bool clampToBounds();

 private:
  std::list<std::pair<float, float>> path_;
  CollisionDetector collision_;
  double x_min_, x_max_, y_min_, y_max_;
  arma::vec D;
  arma::vec D2;
  RandomDoubleGenerator random_device_;
  int id_;

   /**
   * @brief samples points around a center point with a bias towards the center
   * @param sampling_radius the radius within which to sample points
   * @param center the center point around which to sample
   * @return sampled point (x, y)
   * @note The bias is controlled by the spiral_shape parameter, which is a float value
   */
  std::pair<float, float> biasedSampling(const std::pair<float, float> &center);

};

} 

#endif // GLWOA_RRTSTAR_PLANNER_WOA_AGENT_HPP_  // NOLINT 