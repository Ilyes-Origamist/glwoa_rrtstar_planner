/* ******************************
  Copyright 2025 - Ilyes Chaabeni
  Copyright 2021 - Rafael Barreto
 ****************************** */

#ifndef GLWOA_RRTSTAR_PLANNER_RRT_STAR_HPP_  // NOLINT
#define GLWOA_RRTSTAR_PLANNER_RRT_STAR_HPP_

#include <ros/ros.h>
#include <costmap_2d/costmap_2d.h>

#include <cmath>
#include <vector>
#include <list>
#include <utility>

#include "glwoa_rrtstar_planner/random_double_generator.hpp"
#include "glwoa_rrtstar_planner/node.hpp"
#include "glwoa_rrtstar_planner/collision_detector.hpp"

namespace glwoa_rrtstar_planner {

/* TODO: Implement a dynamic KD-Tree (you can use OMPL's implementation or nanoflann) to speed up the nearest neighbors search.
*  NOTE:
* Most of the time taken by RRT* is spent in the nearest neighbor search, especially when the number of nodes increases.
* So it's important to improve this part for better performance (if we compare to A* which uses a priority queue).
* I have tried using OMPL's KD-Tree, but it was slow for my use case. I may have done something wrong (I can share the code if you want).
* For this class, I have implemented a simple spatial grid for nearest neighbor search. It can be more efficient than a true KD-tree.
*/

/**
 * @brief Class for implementing the RRT* algorithm with improved performance using spatial indexing for nearest neighbor search.
 */
class RRTStar {
 public:
 /**
  * @brief Constructor for RRTStar
  * @param start_point The starting point of the RRT* algorithm
  * @param goal_point The goal point of the RRT* algorithm
  * @param costmap Pointer to the costmap used for collision detection
  * @param goal_tolerance The distance below which the goal is considered reached
  * @param rewiring_radius The neighboring radius for the circular area around the new node
  * @param epsilon The step value for the RRT* algorithm (controls expansion of the tree)
  * @param max_num_nodes The maximum number of nodes allowed in the RRT* tree
  * @param min_num_nodes The minimum number (not used) of nodes to be maintained in the RRT* tree
  */
  RRTStar(const std::pair<float, float> &start_point,
          const std::pair<float, float> &goal_point,
          costmap_2d::Costmap2D* costmap,
          double goal_tolerance,
          double rewiring_radius,
          double epsilon,
          unsigned int max_num_nodes,
          unsigned int min_num_nodes);

  /**
   * @brief compute the RRT* initial path only
   * @param path list of planar positions (x, y)
   * @return true if a path is found, false otherwise (max number of nodes reached or goal position collides)
   */
  bool initialPath(std::list<std::pair<float, float>> &path);  // NOLINT

  /**
   * @brief refines the RRT* initial path once generated
   * @param path list of planar positions (x, y)
   * @return true if a path is found, false otherwise
   */
  bool refinePath(std::list<std::pair<float, float>> &path);

  /** 
   * @brief Computes the path generated by RRT* algorithm using backtracking from the goal node
   * @param path to be modified by the method (pass a data member): list of planar positions (x, y)
   * @note It starts from the goal node and moves through parents until reaching the start node. 
   */
  void computeFinalPath(std::list<std::pair<float, float>> &path);  // NOLINT

  /**
 * @brief Checks if the goal is reached based on the goal tolerance
 * @return true if the goal is reached, false otherwise
 */
  bool isGoalReached(const std::pair<float, float> &p_new) {
  return (euclideanDistance2D(p_new.first,
                              p_new.second,
                              goal_point_.first,
                              goal_point_.second) < goal_tolerance_) ? true : false;
  }

 public:
  // Getters and helpers for private members
  /**
   * @brief Get the vector of nodes in the RRT* tree
   * @return vector of Node objects representing the RRT* tree
   */
  std::vector<Node> getNodes() const {
    return nodes_;
  }

  size_t getNodeCount() const {
    return nodes_.size();
  }

 /**
 * @brief Get the cost of the path found by RRT*
 * @return float representing the cost of the path
 */
  float getPathCost() const {
    return path_cost_;
  }

  /**
   * @brief Check if maximum number of nodes was reached
   * @return true if max nodes reached, false otherwise
   */
  bool isMaxNodesReached() const {
    return max_nodes_reached_;
  }

  /**
   * @brief Reset the node vector (whole RRT* tree)
   */
  void resetNodeVector() {
    nodes_.clear();
    nodes_.reserve(max_num_nodes_);
    max_nodes_reached_ = false;
    node_count_ = 0;
  }

 private:
  // Data members
  float path_cost_{0.0};  // Total cost of the path found
  std::pair<float, float> start_point_;
  std::pair<float, float> goal_point_;
  costmap_2d::Costmap2D* costmap_{nullptr};
  CollisionDetector cd_;
  std::vector<Node> nodes_;
  Node goal_node_;
  RandomDoubleGenerator random_double_;
  std::pair<std::pair<double, double>, std::pair<double, double>> map_bounds;

  double rewiring_radius_;
  double epsilon_;
  unsigned int max_num_nodes_;
  unsigned int min_num_nodes_;
  double goal_tolerance_;

  bool goal_reached_{false};
  bool max_nodes_reached_{false};
  int node_count_{0};            

  /*
  * Spatial indexing for efficient nearest neighbor queries.
  * - A vector of vectors to store the indices of nodes in each grid cell.
  * - Each element of `spatial_grid_[i]` contains all the nodes' IDs that are in the cell `i`.
  * 
  * Rationale:
  * - The map is divided into a grid with square cells of size `grid_cell_size_`.
  * - Each cell can contain multiple nodes.
  * - By setting the grid cell size to `2*rewiring_radius_`, we ensure that any point
  *  within the radius is contained in one of the 4 neighboring cells, no more.
  * - This allows for efficient nearest neighbors search.
  * Limitation:
  * - The nearest node from the new sampled point is not guaranteed to be within the rewiring radius,
  *  especially in the early iterations.
  * - If this is the case, a fallback to brute force search is used.
  * - Thus, search for the nearest node is not always optimized. 
  * - A better approach may be a greedy algorithm that finds the nearest grid and extend the search to neighboring grids.
  */
  std::vector<std::vector<int>> spatial_grid_;
  
  /*
  * Grid cell size: using `rewiring_radius_ * 2` ensures that any point within the search radius is contained within at least one of the four neighboring cells.
  * This is crucial for efficient nearest neighbor searches.
  * 
  * Rationale:
  * - The search radius defines the area around a node where we look for neighbors.
  * - By setting the cell size to `rewiring_radius_ * 2`, we ensure that any point within the radius from a node
  *   must lie within one of 4 neighboring cells (in a 2x2 region).
  * - This is because the search radius defines a circular area, and the
  *   `rewiring_radius_ * 2` ensures that the circle fits within a square of side length `rewiring_radius_ * 2`.
  */
  float grid_cell_size_;
  
  float grid_min_x_;      // Minimum X coordinate of the grid
  float grid_min_y_;      // Minimum Y coordinate of the grid
  int grid_width_;        // Width of the grid (in cells)
  int grid_height_;       // Height of the grid (in cells)

  /*
  * This vector is used to store the indices of nearby nodes found in the 4 grids surrounding the region of near neighbors (circle) with a grid size = `2*rewiring_radius_`.
  * 
  * Thus, search of neighboring nodes is optimized by only checking these indices
  *  (of nodes lying inside the 4 neighboring cells) instead of all nodes in the RRT* tree.
  */
  std::vector<int> near_node_indices_;
  
  // Timing variables for performance analysis
  double time_nearest_node_{0.0}; // time spent by finding the nearest node
  double time_near_nodes_{0.0}; // time spent by finding the nearest nodes (rewiring radius)
  double time_collision_check_{0.0}; // time spent by collision checks

  // Internal algorithm methods
  /**
   * @brief sample a random 2D point
   * @return a random planar position (x, y)
   */
  std::pair<float, float> sampleFree();

  /**
   * @brief Create a new node and update the spatial grid
   * @param x cartesian coordinate of the new node
   * @param y cartesian coordinate of the new node
   * @param nearest_node_id nearest node index
   * @param near_indices precomputed nearby node indices for optimization
   */
  void createNewNode(float x, float y, int nearest_node_id, const std::vector<int>& near_indices);

  /**
   * @brief Get nearby nodes within a certain radius using spatial grid search for a more efficient search
   * @param point the center point
   * @param radius the search radius
   * @param result vector to store the indices of nearby nodes (passed by reference)
   */
  void getNearNodes(const std::pair<float, float> &point, float radius, std::vector<int> &result);

  /**
   * @brief Get the index of the nearest node of a point using a spatial grid with a fallback to brute force
   * @param point the sampled random point
   * @return the nearest node index
   */
  int getNearestNodeId(const std::pair<float, float> &point);

  /**
   * @brief Get the index of the nearest node around the new random point using brute force search
   * @param point the sampled random point
   * @return the nearest node index
   */
  int getNearestNodeBruteForce(const std::pair<float, float> &point);

  /**
   * @brief RRT* parent selection with spatial grid search (recommended)
   * @param nearest_node_id index of the nearest node around the new node
   * @param near_indices precomputed nearby node indices for optimization
   */
  void chooseParent(int nearest_node_id, const std::vector<int>& near_indices);

  /**
   * @brief RRT* parent selection using brute force search (fallback method)
   * @param nearest_node_id index of the nearest node around the new node
   */
  void chooseParentBruteForce(int nearest_node_id);

  /**
   * @brief RRT* rewiring with spatial grid search (recommended)
   * @param near_indices precomputed nearby nodes' indices for optimization
   */
  void rewire(const std::vector<int>& near_indices);

  /**
   * @brief RRT* rewiring using brute force search (fallback method)
   */
  void rewireBruteForce();

  /**
   * @brief Steer function to limit the expansion step
   */
  std::pair<float, float> steer(float x1, float y1, float x2, float y2);

  /**
   * @brief Assign the new node to the corresponding grid cell (index) in the spatial grid structure
   * @param node the new Node object to add
   */
  void updateSpatialGrid(const Node& node);
};

}  // namespace glwoa_rrtstar_planner

#endif  // GLWOA_RRTSTAR_PLANNER_RRT_STAR_HPP_  NOLINT
